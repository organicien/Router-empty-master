{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends, __values } from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { Corner, CornerBit, cssClasses, numbers, strings } from './constants';\n\nvar MDCMenuSurfaceFoundation =\n/** @class */\nfunction (_super) {\n  __extends(MDCMenuSurfaceFoundation, _super);\n\n  function MDCMenuSurfaceFoundation(adapter) {\n    var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;\n\n    _this.isSurfaceOpen = false;\n    _this.isQuickOpen = false;\n    _this.isHoistedElement = false;\n    _this.isFixedPosition = false;\n    _this.openAnimationEndTimerId = 0;\n    _this.closeAnimationEndTimerId = 0;\n    _this.animationRequestId = 0;\n    _this.anchorCorner = Corner.TOP_START;\n    /**\n     * Corner of the menu surface to which menu surface is attached to anchor.\n     *\n     *  Anchor corner --->+----------+\n     *                    |  ANCHOR  |\n     *                    +----------+\n     *  Origin corner --->+--------------+\n     *                    |              |\n     *                    |              |\n     *                    | MENU SURFACE |\n     *                    |              |\n     *                    |              |\n     *                    +--------------+\n     */\n\n    _this.originCorner = Corner.TOP_START;\n    _this.anchorMargin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    _this.position = {\n      x: 0,\n      y: 0\n    };\n    return _this;\n  }\n\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"cssClasses\", {\n    get: function () {\n      return cssClasses;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"strings\", {\n    get: function () {\n      return strings;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"numbers\", {\n    get: function () {\n      return numbers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"Corner\", {\n    get: function () {\n      return Corner;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"defaultAdapter\", {\n    /**\n     * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n     */\n    get: function () {\n      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n      return {\n        addClass: function () {\n          return undefined;\n        },\n        removeClass: function () {\n          return undefined;\n        },\n        hasClass: function () {\n          return false;\n        },\n        hasAnchor: function () {\n          return false;\n        },\n        isElementInContainer: function () {\n          return false;\n        },\n        isFocused: function () {\n          return false;\n        },\n        isRtl: function () {\n          return false;\n        },\n        getInnerDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getAnchorDimensions: function () {\n          return null;\n        },\n        getWindowDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getBodyDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getWindowScroll: function () {\n          return {\n            x: 0,\n            y: 0\n          };\n        },\n        setPosition: function () {\n          return undefined;\n        },\n        setMaxHeight: function () {\n          return undefined;\n        },\n        setTransformOrigin: function () {\n          return undefined;\n        },\n        saveFocus: function () {\n          return undefined;\n        },\n        restoreFocus: function () {\n          return undefined;\n        },\n        notifyClose: function () {\n          return undefined;\n        },\n        notifyOpen: function () {\n          return undefined;\n        }\n      }; // tslint:enable:object-literal-sort-keys\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MDCMenuSurfaceFoundation.prototype.init = function () {\n    var _a = MDCMenuSurfaceFoundation.cssClasses,\n        ROOT = _a.ROOT,\n        OPEN = _a.OPEN;\n\n    if (!this.adapter.hasClass(ROOT)) {\n      throw new Error(ROOT + \" class required in root element.\");\n    }\n\n    if (this.adapter.hasClass(OPEN)) {\n      this.isSurfaceOpen = true;\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.destroy = function () {\n    clearTimeout(this.openAnimationEndTimerId);\n    clearTimeout(this.closeAnimationEndTimerId); // Cancel any currently running animations.\n\n    cancelAnimationFrame(this.animationRequestId);\n  };\n  /**\n   * @param corner Default anchor corner alignment of top-left menu surface corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {\n    this.anchorCorner = corner;\n  };\n  /**\n   * Flip menu corner horizontally.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function () {\n    this.originCorner = this.originCorner ^ CornerBit.RIGHT;\n  };\n  /**\n   * @param margin Set of margin values from anchor.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {\n    this.anchorMargin.top = margin.top || 0;\n    this.anchorMargin.right = margin.right || 0;\n    this.anchorMargin.bottom = margin.bottom || 0;\n    this.anchorMargin.left = margin.left || 0;\n  };\n  /** Used to indicate if the menu-surface is hoisted to the body. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {\n    this.isHoistedElement = isHoisted;\n  };\n  /** Used to set the menu-surface calculations based on a fixed position menu. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {\n    this.isFixedPosition = isFixedPosition;\n  };\n  /** Sets the menu-surface position on the page. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {\n    this.position.x = this.isFinite(x) ? x : 0;\n    this.position.y = this.isFinite(y) ? y : 0;\n  };\n\n  MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {\n    this.isQuickOpen = quickOpen;\n  };\n\n  MDCMenuSurfaceFoundation.prototype.isOpen = function () {\n    return this.isSurfaceOpen;\n  };\n  /**\n   * Open the menu surface.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.open = function () {\n    var _this = this;\n\n    if (this.isSurfaceOpen) {\n      return;\n    }\n\n    this.adapter.saveFocus();\n\n    if (this.isQuickOpen) {\n      this.isSurfaceOpen = true;\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n      this.dimensions = this.adapter.getInnerDimensions();\n      this.autoposition();\n      this.adapter.notifyOpen();\n    } else {\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n      this.animationRequestId = requestAnimationFrame(function () {\n        _this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n\n        _this.dimensions = _this.adapter.getInnerDimensions();\n\n        _this.autoposition();\n\n        _this.openAnimationEndTimerId = setTimeout(function () {\n          _this.openAnimationEndTimerId = 0;\n\n          _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n\n          _this.adapter.notifyOpen();\n        }, numbers.TRANSITION_OPEN_DURATION);\n      });\n      this.isSurfaceOpen = true;\n    }\n  };\n  /**\n   * Closes the menu surface.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {\n    var _this = this;\n\n    if (skipRestoreFocus === void 0) {\n      skipRestoreFocus = false;\n    }\n\n    if (!this.isSurfaceOpen) {\n      return;\n    }\n\n    if (this.isQuickOpen) {\n      this.isSurfaceOpen = false;\n\n      if (!skipRestoreFocus) {\n        this.maybeRestoreFocus();\n      }\n\n      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n      this.adapter.notifyClose();\n    } else {\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n      requestAnimationFrame(function () {\n        _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n\n        _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n\n        _this.closeAnimationEndTimerId = setTimeout(function () {\n          _this.closeAnimationEndTimerId = 0;\n\n          _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n\n          _this.adapter.notifyClose();\n        }, numbers.TRANSITION_CLOSE_DURATION);\n      });\n      this.isSurfaceOpen = false;\n\n      if (!skipRestoreFocus) {\n        this.maybeRestoreFocus();\n      }\n    }\n  };\n  /** Handle clicks and close if not within menu-surface element. */\n\n\n  MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {\n    var el = evt.target;\n\n    if (this.adapter.isElementInContainer(el)) {\n      return;\n    }\n\n    this.close();\n  };\n  /** Handle keys that close the surface. */\n\n\n  MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {\n    var keyCode = evt.keyCode,\n        key = evt.key;\n    var isEscape = key === 'Escape' || keyCode === 27;\n\n    if (isEscape) {\n      this.close();\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.autoposition = function () {\n    var _a; // Compute measurements for autoposition methods reuse.\n\n\n    this.measurements = this.getAutoLayoutmeasurements();\n    var corner = this.getoriginCorner();\n    var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\n    var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n    var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\n    var horizontalOffset = this.getHorizontalOriginOffset(corner);\n    var verticalOffset = this.getVerticalOriginOffset(corner);\n    var _b = this.measurements,\n        anchorSize = _b.anchorSize,\n        surfaceSize = _b.surfaceSize;\n    var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a); // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.\n\n    if (anchorSize.width / surfaceSize.width > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element\n\n\n    if (this.isHoistedElement || this.isFixedPosition) {\n      this.adjustPositionForHoistedElement(position);\n    }\n\n    this.adapter.setTransformOrigin(horizontalAlignment + \" \" + verticalAlignment);\n    this.adapter.setPosition(position);\n    this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // If it is opened from the top then add is-open-below class\n\n    if (!this.hasBit(corner, CornerBit.BOTTOM)) {\n      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n    }\n  };\n  /**\n   * @return Measurements used to position menu surface popup.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getAutoLayoutmeasurements = function () {\n    var anchorRect = this.adapter.getAnchorDimensions();\n    var bodySize = this.adapter.getBodyDimensions();\n    var viewportSize = this.adapter.getWindowDimensions();\n    var windowScroll = this.adapter.getWindowScroll();\n\n    if (!anchorRect) {\n      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n      anchorRect = {\n        top: this.position.y,\n        right: this.position.x,\n        bottom: this.position.y,\n        left: this.position.x,\n        width: 0,\n        height: 0\n      }; // tslint:enable:object-literal-sort-keys\n    }\n\n    return {\n      anchorSize: anchorRect,\n      bodySize: bodySize,\n      surfaceSize: this.dimensions,\n      viewportDistance: {\n        // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n        top: anchorRect.top,\n        right: viewportSize.width - anchorRect.right,\n        bottom: viewportSize.height - anchorRect.bottom,\n        left: anchorRect.left\n      },\n      viewportSize: viewportSize,\n      windowScroll: windowScroll\n    };\n  };\n  /**\n   * Computes the corner of the anchor from which to animate and position the\n   * menu surface.\n   *\n   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\n   * context. E.g., menu surface will be positioned from right side on TOP_END.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getoriginCorner = function () {\n    var corner = this.originCorner;\n    var _a = this.measurements,\n        viewportDistance = _a.viewportDistance,\n        anchorSize = _a.anchorSize,\n        surfaceSize = _a.surfaceSize;\n    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n    var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n    var availableTop;\n    var availableBottom;\n\n    if (isAnchoredToBottom) {\n      availableTop = viewportDistance.top - MARGIN_TO_EDGE + anchorSize.height + this.anchorMargin.bottom;\n      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\n    } else {\n      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\n      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;\n    }\n\n    var isAvailableBottom = availableBottom - surfaceSize.height > 0;\n\n    if (!isAvailableBottom && availableTop >= availableBottom) {\n      // Attach bottom side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.BOTTOM);\n    }\n\n    var isRtl = this.adapter.isRtl();\n    var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\n    var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT); // Whether surface attached to right side of anchor element.\n\n    var isAnchoredToRight = false; // Anchored to start\n\n    if (isRtl && isFlipRtl) {\n      isAnchoredToRight = !hasRightBit;\n    } else {\n      // Anchored to right\n      isAnchoredToRight = hasRightBit;\n    }\n\n    var availableLeft;\n    var availableRight;\n\n    if (isAnchoredToRight) {\n      availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;\n      availableRight = viewportDistance.right - this.anchorMargin.right;\n    } else {\n      availableLeft = viewportDistance.left + this.anchorMargin.left;\n      availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;\n    }\n\n    var isAvailableLeft = availableLeft - surfaceSize.width > 0;\n    var isAvailableRight = availableRight - surfaceSize.width > 0;\n    var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);\n\n    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {\n      // Attach left side of surface to the anchor.\n      corner = this.unsetBit(corner, CornerBit.RIGHT);\n    } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {\n      // Attach right side of surface to the anchor.\n      corner = this.setBit(corner, CornerBit.RIGHT);\n    }\n\n    return corner;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight = function (corner) {\n    var viewportDistance = this.measurements.viewportDistance;\n    var maxHeight = 0;\n    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from CSS.\n\n    if (isBottomAligned) {\n      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\n\n      if (!isBottomAnchored) {\n        maxHeight += this.measurements.anchorSize.height;\n      }\n    } else {\n      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;\n\n      if (isBottomAnchored) {\n        maxHeight -= this.measurements.anchorSize.height;\n      }\n    }\n\n    return maxHeight;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset = function (corner) {\n    var anchorSize = this.measurements.anchorSize; // isRightAligned corresponds to using the 'right' property on the surface.\n\n    var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\n    var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n\n    if (isRightAligned) {\n      var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right; // For hoisted or fixed elements, adjust the offset by the difference\n      // between viewport width and body width so when we calculate the right\n      // value (`adjustPositionForHoistedElement`) based on the element\n      // position, the right property is correct.\n\n      if (this.isHoistedElement || this.isFixedPosition) {\n        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);\n      }\n\n      return rightOffset;\n    }\n\n    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Vertical offset of menu surface origin corner from corresponding anchor corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset = function (corner) {\n    var anchorSize = this.measurements.anchorSize;\n    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n    var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n    var y = 0;\n\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;\n    } else {\n      y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;\n    }\n\n    return y;\n  };\n  /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */\n\n\n  MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement = function (position) {\n    var e_1, _a;\n\n    var _b = this.measurements,\n        windowScroll = _b.windowScroll,\n        viewportDistance = _b.viewportDistance;\n    var props = Object.keys(position);\n\n    try {\n      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n        var prop = props_1_1.value;\n        var value = position[prop] || 0; // Hoisted surfaces need to have the anchor elements location on the page added to the\n        // position properties for proper alignment on the body.\n\n        value += viewportDistance[prop]; // Surfaces that are absolutely positioned need to have additional calculations for scroll\n        // and bottom positioning.\n\n        if (!this.isFixedPosition) {\n          if (prop === 'top') {\n            value += windowScroll.y;\n          } else if (prop === 'bottom') {\n            value -= windowScroll.y;\n          } else if (prop === 'left') {\n            value += windowScroll.x;\n          } else {\n            // prop === 'right'\n            value -= windowScroll.x;\n          }\n        }\n\n        position[prop] = value;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * The last focused element when the menu surface was opened should regain focus, if the user is\n   * focused on or within the menu surface when it is closed.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus = function () {\n    var isRootFocused = this.adapter.isFocused();\n    var childHasFocus = document.activeElement && this.adapter.isElementInContainer(document.activeElement);\n\n    if (isRootFocused || childHasFocus) {\n      this.adapter.restoreFocus();\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.hasBit = function (corner, bit) {\n    return Boolean(corner & bit); // tslint:disable-line:no-bitwise\n  };\n\n  MDCMenuSurfaceFoundation.prototype.setBit = function (corner, bit) {\n    return corner | bit; // tslint:disable-line:no-bitwise\n  };\n\n  MDCMenuSurfaceFoundation.prototype.unsetBit = function (corner, bit) {\n    return corner ^ bit;\n  };\n  /**\n   * isFinite that doesn't force conversion to number type.\n   * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.isFinite = function (num) {\n    return typeof num === 'number' && isFinite(num);\n  };\n\n  return MDCMenuSurfaceFoundation;\n}(MDCFoundation);\n\nexport { MDCMenuSurfaceFoundation }; // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n\nexport default MDCMenuSurfaceFoundation;","map":{"version":3,"sources":["foundation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends, __values } from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { Corner, CornerBit, cssClasses, numbers, strings } from './constants';\nvar MDCMenuSurfaceFoundation = /** @class */ (function (_super) {\n    __extends(MDCMenuSurfaceFoundation, _super);\n    function MDCMenuSurfaceFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;\n        _this.isSurfaceOpen = false;\n        _this.isQuickOpen = false;\n        _this.isHoistedElement = false;\n        _this.isFixedPosition = false;\n        _this.openAnimationEndTimerId = 0;\n        _this.closeAnimationEndTimerId = 0;\n        _this.animationRequestId = 0;\n        _this.anchorCorner = Corner.TOP_START;\n        /**\n         * Corner of the menu surface to which menu surface is attached to anchor.\n         *\n         *  Anchor corner --->+----------+\n         *                    |  ANCHOR  |\n         *                    +----------+\n         *  Origin corner --->+--------------+\n         *                    |              |\n         *                    |              |\n         *                    | MENU SURFACE |\n         *                    |              |\n         *                    |              |\n         *                    +--------------+\n         */\n        _this.originCorner = Corner.TOP_START;\n        _this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };\n        _this.position = { x: 0, y: 0 };\n        return _this;\n    }\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"cssClasses\", {\n        get: function () {\n            return cssClasses;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"strings\", {\n        get: function () {\n            return strings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"numbers\", {\n        get: function () {\n            return numbers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"Corner\", {\n        get: function () {\n            return Corner;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"defaultAdapter\", {\n        /**\n         * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n         */\n        get: function () {\n            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n            return {\n                addClass: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                hasClass: function () { return false; },\n                hasAnchor: function () { return false; },\n                isElementInContainer: function () { return false; },\n                isFocused: function () { return false; },\n                isRtl: function () { return false; },\n                getInnerDimensions: function () { return ({ height: 0, width: 0 }); },\n                getAnchorDimensions: function () { return null; },\n                getWindowDimensions: function () { return ({ height: 0, width: 0 }); },\n                getBodyDimensions: function () { return ({ height: 0, width: 0 }); },\n                getWindowScroll: function () { return ({ x: 0, y: 0 }); },\n                setPosition: function () { return undefined; },\n                setMaxHeight: function () { return undefined; },\n                setTransformOrigin: function () { return undefined; },\n                saveFocus: function () { return undefined; },\n                restoreFocus: function () { return undefined; },\n                notifyClose: function () { return undefined; },\n                notifyOpen: function () { return undefined; },\n            };\n            // tslint:enable:object-literal-sort-keys\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MDCMenuSurfaceFoundation.prototype.init = function () {\n        var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;\n        if (!this.adapter.hasClass(ROOT)) {\n            throw new Error(ROOT + \" class required in root element.\");\n        }\n        if (this.adapter.hasClass(OPEN)) {\n            this.isSurfaceOpen = true;\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.destroy = function () {\n        clearTimeout(this.openAnimationEndTimerId);\n        clearTimeout(this.closeAnimationEndTimerId);\n        // Cancel any currently running animations.\n        cancelAnimationFrame(this.animationRequestId);\n    };\n    /**\n     * @param corner Default anchor corner alignment of top-left menu surface corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {\n        this.anchorCorner = corner;\n    };\n    /**\n     * Flip menu corner horizontally.\n     */\n    MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function () {\n        this.originCorner = this.originCorner ^ CornerBit.RIGHT;\n    };\n    /**\n     * @param margin Set of margin values from anchor.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {\n        this.anchorMargin.top = margin.top || 0;\n        this.anchorMargin.right = margin.right || 0;\n        this.anchorMargin.bottom = margin.bottom || 0;\n        this.anchorMargin.left = margin.left || 0;\n    };\n    /** Used to indicate if the menu-surface is hoisted to the body. */\n    MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {\n        this.isHoistedElement = isHoisted;\n    };\n    /** Used to set the menu-surface calculations based on a fixed position menu. */\n    MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {\n        this.isFixedPosition = isFixedPosition;\n    };\n    /** Sets the menu-surface position on the page. */\n    MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {\n        this.position.x = this.isFinite(x) ? x : 0;\n        this.position.y = this.isFinite(y) ? y : 0;\n    };\n    MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {\n        this.isQuickOpen = quickOpen;\n    };\n    MDCMenuSurfaceFoundation.prototype.isOpen = function () {\n        return this.isSurfaceOpen;\n    };\n    /**\n     * Open the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.open = function () {\n        var _this = this;\n        if (this.isSurfaceOpen) {\n            return;\n        }\n        this.adapter.saveFocus();\n        if (this.isQuickOpen) {\n            this.isSurfaceOpen = true;\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            this.dimensions = this.adapter.getInnerDimensions();\n            this.autoposition();\n            this.adapter.notifyOpen();\n        }\n        else {\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n            this.animationRequestId = requestAnimationFrame(function () {\n                _this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n                _this.dimensions = _this.adapter.getInnerDimensions();\n                _this.autoposition();\n                _this.openAnimationEndTimerId = setTimeout(function () {\n                    _this.openAnimationEndTimerId = 0;\n                    _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n                    _this.adapter.notifyOpen();\n                }, numbers.TRANSITION_OPEN_DURATION);\n            });\n            this.isSurfaceOpen = true;\n        }\n    };\n    /**\n     * Closes the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {\n        var _this = this;\n        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }\n        if (!this.isSurfaceOpen) {\n            return;\n        }\n        if (this.isQuickOpen) {\n            this.isSurfaceOpen = false;\n            if (!skipRestoreFocus) {\n                this.maybeRestoreFocus();\n            }\n            this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n            this.adapter.notifyClose();\n        }\n        else {\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n            requestAnimationFrame(function () {\n                _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n                _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n                _this.closeAnimationEndTimerId = setTimeout(function () {\n                    _this.closeAnimationEndTimerId = 0;\n                    _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n                    _this.adapter.notifyClose();\n                }, numbers.TRANSITION_CLOSE_DURATION);\n            });\n            this.isSurfaceOpen = false;\n            if (!skipRestoreFocus) {\n                this.maybeRestoreFocus();\n            }\n        }\n    };\n    /** Handle clicks and close if not within menu-surface element. */\n    MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {\n        var el = evt.target;\n        if (this.adapter.isElementInContainer(el)) {\n            return;\n        }\n        this.close();\n    };\n    /** Handle keys that close the surface. */\n    MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {\n        var keyCode = evt.keyCode, key = evt.key;\n        var isEscape = key === 'Escape' || keyCode === 27;\n        if (isEscape) {\n            this.close();\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.autoposition = function () {\n        var _a;\n        // Compute measurements for autoposition methods reuse.\n        this.measurements = this.getAutoLayoutmeasurements();\n        var corner = this.getoriginCorner();\n        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);\n        var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n        var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';\n        var horizontalOffset = this.getHorizontalOriginOffset(corner);\n        var verticalOffset = this.getVerticalOriginOffset(corner);\n        var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;\n        var position = (_a = {},\n            _a[horizontalAlignment] = horizontalOffset,\n            _a[verticalAlignment] = verticalOffset,\n            _a);\n        // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.\n        if (anchorSize.width / surfaceSize.width > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n            horizontalAlignment = 'center';\n        }\n        // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element\n        if (this.isHoistedElement || this.isFixedPosition) {\n            this.adjustPositionForHoistedElement(position);\n        }\n        this.adapter.setTransformOrigin(horizontalAlignment + \" \" + verticalAlignment);\n        this.adapter.setPosition(position);\n        this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n        // If it is opened from the top then add is-open-below class\n        if (!this.hasBit(corner, CornerBit.BOTTOM)) {\n            this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);\n        }\n    };\n    /**\n     * @return Measurements used to position menu surface popup.\n     */\n    MDCMenuSurfaceFoundation.prototype.getAutoLayoutmeasurements = function () {\n        var anchorRect = this.adapter.getAnchorDimensions();\n        var bodySize = this.adapter.getBodyDimensions();\n        var viewportSize = this.adapter.getWindowDimensions();\n        var windowScroll = this.adapter.getWindowScroll();\n        if (!anchorRect) {\n            // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n            anchorRect = {\n                top: this.position.y,\n                right: this.position.x,\n                bottom: this.position.y,\n                left: this.position.x,\n                width: 0,\n                height: 0,\n            };\n            // tslint:enable:object-literal-sort-keys\n        }\n        return {\n            anchorSize: anchorRect,\n            bodySize: bodySize,\n            surfaceSize: this.dimensions,\n            viewportDistance: {\n                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n                top: anchorRect.top,\n                right: viewportSize.width - anchorRect.right,\n                bottom: viewportSize.height - anchorRect.bottom,\n                left: anchorRect.left,\n            },\n            viewportSize: viewportSize,\n            windowScroll: windowScroll,\n        };\n    };\n    /**\n     * Computes the corner of the anchor from which to animate and position the\n     * menu surface.\n     *\n     * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL\n     * context. E.g., menu surface will be positioned from right side on TOP_END.\n     */\n    MDCMenuSurfaceFoundation.prototype.getoriginCorner = function () {\n        var corner = this.originCorner;\n        var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;\n        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n        var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var availableTop;\n        var availableBottom;\n        if (isAnchoredToBottom) {\n            availableTop = viewportDistance.top - MARGIN_TO_EDGE + anchorSize.height +\n                this.anchorMargin.bottom;\n            availableBottom =\n                viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;\n        }\n        else {\n            availableTop =\n                viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;\n            availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE +\n                anchorSize.height - this.anchorMargin.top;\n        }\n        var isAvailableBottom = availableBottom - surfaceSize.height > 0;\n        if (!isAvailableBottom && availableTop >= availableBottom) {\n            // Attach bottom side of surface to the anchor.\n            corner = this.setBit(corner, CornerBit.BOTTOM);\n        }\n        var isRtl = this.adapter.isRtl();\n        var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);\n        var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n        // Whether surface attached to right side of anchor element.\n        var isAnchoredToRight = false;\n        // Anchored to start\n        if (isRtl && isFlipRtl) {\n            isAnchoredToRight = !hasRightBit;\n        }\n        else {\n            // Anchored to right\n            isAnchoredToRight = hasRightBit;\n        }\n        var availableLeft;\n        var availableRight;\n        if (isAnchoredToRight) {\n            availableLeft =\n                viewportDistance.left + anchorSize.width + this.anchorMargin.right;\n            availableRight = viewportDistance.right - this.anchorMargin.right;\n        }\n        else {\n            availableLeft = viewportDistance.left + this.anchorMargin.left;\n            availableRight =\n                viewportDistance.right + anchorSize.width - this.anchorMargin.left;\n        }\n        var isAvailableLeft = availableLeft - surfaceSize.width > 0;\n        var isAvailableRight = availableRight - surfaceSize.width > 0;\n        var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) &&\n            this.hasBit(corner, CornerBit.RIGHT);\n        if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl ||\n            !isAvailableLeft && isOriginCornerAlignedToEnd) {\n            // Attach left side of surface to the anchor.\n            corner = this.unsetBit(corner, CornerBit.RIGHT);\n        }\n        else if (isAvailableLeft && isAnchoredToRight && isRtl ||\n            (isAvailableLeft && !isAnchoredToRight && hasRightBit) ||\n            (!isAvailableRight && availableLeft >= availableRight)) {\n            // Attach right side of surface to the anchor.\n            corner = this.setBit(corner, CornerBit.RIGHT);\n        }\n        return corner;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.\n     */\n    MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight = function (corner) {\n        var viewportDistance = this.measurements.viewportDistance;\n        var maxHeight = 0;\n        var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n        var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n        // When maximum height is not specified, it is handled from CSS.\n        if (isBottomAligned) {\n            maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;\n            if (!isBottomAnchored) {\n                maxHeight += this.measurements.anchorSize.height;\n            }\n        }\n        else {\n            maxHeight = viewportDistance.bottom - this.anchorMargin.bottom +\n                this.measurements.anchorSize.height - MARGIN_TO_EDGE;\n            if (isBottomAnchored) {\n                maxHeight -= this.measurements.anchorSize.height;\n            }\n        }\n        return maxHeight;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset = function (corner) {\n        var anchorSize = this.measurements.anchorSize;\n        // isRightAligned corresponds to using the 'right' property on the surface.\n        var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);\n        var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);\n        if (isRightAligned) {\n            var rightOffset = avoidHorizontalOverlap ?\n                anchorSize.width - this.anchorMargin.left :\n                this.anchorMargin.right;\n            // For hoisted or fixed elements, adjust the offset by the difference\n            // between viewport width and body width so when we calculate the right\n            // value (`adjustPositionForHoistedElement`) based on the element\n            // position, the right property is correct.\n            if (this.isHoistedElement || this.isFixedPosition) {\n                return rightOffset -\n                    (this.measurements.viewportSize.width -\n                        this.measurements.bodySize.width);\n            }\n            return rightOffset;\n        }\n        return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right :\n            this.anchorMargin.left;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Vertical offset of menu surface origin corner from corresponding anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset = function (corner) {\n        var anchorSize = this.measurements.anchorSize;\n        var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);\n        var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);\n        var y = 0;\n        if (isBottomAligned) {\n            y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top :\n                -this.anchorMargin.bottom;\n        }\n        else {\n            y = avoidVerticalOverlap ?\n                (anchorSize.height + this.anchorMargin.bottom) :\n                this.anchorMargin.top;\n        }\n        return y;\n    };\n    /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */\n    MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement = function (position) {\n        var e_1, _a;\n        var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;\n        var props = Object.keys(position);\n        try {\n            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n                var prop = props_1_1.value;\n                var value = position[prop] || 0;\n                // Hoisted surfaces need to have the anchor elements location on the page added to the\n                // position properties for proper alignment on the body.\n                value += viewportDistance[prop];\n                // Surfaces that are absolutely positioned need to have additional calculations for scroll\n                // and bottom positioning.\n                if (!this.isFixedPosition) {\n                    if (prop === 'top') {\n                        value += windowScroll.y;\n                    }\n                    else if (prop === 'bottom') {\n                        value -= windowScroll.y;\n                    }\n                    else if (prop === 'left') {\n                        value += windowScroll.x;\n                    }\n                    else { // prop === 'right'\n                        value -= windowScroll.x;\n                    }\n                }\n                position[prop] = value;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * The last focused element when the menu surface was opened should regain focus, if the user is\n     * focused on or within the menu surface when it is closed.\n     */\n    MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus = function () {\n        var isRootFocused = this.adapter.isFocused();\n        var childHasFocus = document.activeElement &&\n            this.adapter.isElementInContainer(document.activeElement);\n        if (isRootFocused || childHasFocus) {\n            this.adapter.restoreFocus();\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.hasBit = function (corner, bit) {\n        return Boolean(corner & bit); // tslint:disable-line:no-bitwise\n    };\n    MDCMenuSurfaceFoundation.prototype.setBit = function (corner, bit) {\n        return corner | bit; // tslint:disable-line:no-bitwise\n    };\n    MDCMenuSurfaceFoundation.prototype.unsetBit = function (corner, bit) {\n        return corner ^ bit;\n    };\n    /**\n     * isFinite that doesn't force conversion to number type.\n     * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n     */\n    MDCMenuSurfaceFoundation.prototype.isFinite = function (num) {\n        return typeof num === 'number' && isFinite(num);\n    };\n    return MDCMenuSurfaceFoundation;\n}(MDCFoundation));\nexport { MDCMenuSurfaceFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCMenuSurfaceFoundation;\n//# sourceMappingURL=foundation.js.map"]},"metadata":{},"sourceType":"module"}